const inputElem=document.getElementById("input"),elemSelector=document.getElementById("selectElem"),langSelector=document.getElementById("selectLang"),pModeSelector=document.getElementById("pointMode"),decimalElem=document.getElementById("decimalPlaces"),outputElem=document.getElementById("output"),round=(num,precision=0)=>{const shiftedNum=Math.round(num*10**precision);if(0===precision)return shiftedNum;const unshiftedNum=shiftedNum*10**-precision,numStr=unshiftedNum+"",numPart=numStr.split(".");if(!numPart[1])return unshiftedNum;const roundErrFixed=+(numPart[0]+"."+numPart[1].slice(0,precision));return roundErrFixed},getCornersXY=attrs=>{const val=attr=>+attrs[attr].value,cornerArr=[];return cornerArr.push([val("x"),val("y")]),cornerArr.push([val("x")+val("width"),val("y")]),cornerArr.push([val("x")+val("width"),val("y")+val("height")]),cornerArr.push([val("x"),val("y")+val("height")]),cornerArr},DOMTransformer=function(TfList){const TfListLen=TfList.length;let matrixes=[];for(let i=0;i<TfListLen;i++)matrixes.push(TfList[i].matrix);this.applyXY=(x,y)=>{const point=new DOMPoint(x,y),domMatrix=new DOMMatrix;matrixes.forEach(eachMatrix=>domMatrix.multiplySelf(eachMatrix));const returnPoint=point.matrixTransform(domMatrix);return[returnPoint.x,returnPoint.y]}},getParsedElem=(elemHtmlVal,elemName)=>{const parsedDoc=(new DOMParser).parseFromString('<svg xmlns="http://www.w3.org/2000/svg">'+elemHtmlVal+"</svg>","image/svg+xml"),isDOMVaild=parsedDoc.getElementsByTagNameNS("http://www.w3.org/2000/svg",elemName)[0];return isDOMVaild||!1},convertPathValue=(pointArrs,precision=2,pointMode="relative")=>{let cmdFlag="M",d="",beforePoint=[0,0];return pointArrs.forEach(eachPArr=>{cmdFlag=""===d?"M":eachPArr[0]===beforePoint[0]?"V":eachPArr[1]===beforePoint[1]?"H":"L";const roundPArr=eachPArr.map((point,i)=>round("relative"===pointMode?point-beforePoint[i]:point,precision));beforePoint=eachPArr.slice(),d+="V"===cmdFlag?cmdFlag+roundPArr[1]:"H"===cmdFlag?cmdFlag+roundPArr[0]:cmdFlag+roundPArr.join()}),"relative"===pointMode&&(d=d.toLowerCase().replace("m","M")),d+="Z",d},convertPolygonValue=(pointArrs,precision=2)=>{let pointsStr="";return pointArrs.forEach(eachPArr=>{""!==pointsStr&&(pointsStr+=" ");const roundPArr=eachPArr.map(point=>round(point,precision));pointsStr+=roundPArr.join()}),pointsStr},convertProcess=()=>{const inputStr=inputElem.value,elem=elemSelector.value,lang=langSelector.value,pointMode=pModeSelector.value,precision=+decimalElem.value,requireAttrs=["x","y","width","height"];if(!(inputStr&&elem&&lang&&pointMode)||isNaN(precision))return outputElem.textContent="Invalid input",!1;const parsedElem=getParsedElem(inputStr,"rect"),parsedElemAttrs=parsedElem?parsedElem.attributes:{},isVaildAttr=requireAttrs.every(attr=>parsedElemAttrs[attr]);if(!isVaildAttr)return outputElem.textContent="Invalid input",!1;const cornersXY=getCornersXY(parsedElemAttrs),DOMTf=new DOMTransformer(parsedElem.transform.baseVal),transformedP=cornersXY.map(eachCorner=>DOMTf.applyXY(...eachCorner));let pointValue="";"path"===elem?(pModeSelector.disabled=!1,pointValue=convertPathValue(transformedP,precision,pointMode),outputElem.textContent=`<path d="${pointValue}"${"XML"===lang?" /":""}>`):(pModeSelector.disabled=!0,pointValue=convertPolygonValue(transformedP,precision),outputElem.textContent=`<polygon points="${pointValue}"${"XML"===lang?" /":""}>`)};inputElem.addEventListener("input",convertProcess),elemSelector.addEventListener("input",convertProcess),langSelector.addEventListener("input",convertProcess),decimalElem.addEventListener("input",convertProcess),pModeSelector.addEventListener("input",convertProcess);